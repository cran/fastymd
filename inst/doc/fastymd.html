<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
<meta name="generator" content="litedown 0.7">
<title>fastymd</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/css/default.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/css/callout.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/css/article.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@xiee/utils@1.14.14/css/prism-xcode.min.css">
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/js/sidenotes.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/js/copy-button.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/js/callout.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/@xiee/utils@1.13.67/js/toc-highlight.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/components/prism-core.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/prismjs@1.29.0/plugins/autoloader/prism-autoloader.min.js" defer></script>
</head>
<body>
<div class="frontmatter">
<div class="title"><h1>fastymd</h1></div>
</div>
<div class="body">
<div id="TOC">
<ul>
<li><a href="#sec:overview">Overview</a></li>
<li><a href="#sec:benchmarks">Benchmarks</a></li>
</ul>
</div>
<h2 id="sec:overview">Overview</h2>
<p>fastymd is a package for working with Year-Month-Day (YMD) style date objects.
It provides extremely fast passing of character strings and numeric values to
date objects as well as fast decomposition of these in to their year, month
and day components. The underlying algorithms follow the
<a href="https://howardhinnant.github.io/date_algorithms">approach of Howard Hinnant</a>
for calculating days from the <a href="https://en.wikipedia.org/wiki/Unix_time">UNIX Epoch</a>
of <a href="https://en.wikipedia.org/wiki/Gregorian_calendar">Gregorian Calendar</a> dates
and vice versa.</p>
<p>The API won’t give any surprises:</p>
<pre><code class="language-r">library(fastymd)
cdate &lt;- c(&quot;2025-04-16&quot;, &quot;2025-04-17&quot;)
(res &lt;- fymd(cdate))
</code></pre>
<pre><code>#&gt; [1] &quot;2025-04-16&quot; &quot;2025-04-17&quot;
</code></pre>
<pre><code class="language-r">res == as.Date(cdate)
</code></pre>
<pre><code>#&gt; [1] TRUE TRUE
</code></pre>
<pre><code class="language-r">get_ymd(res)
</code></pre>
<pre><code>#&gt;   year month day
#&gt; 1 2025     4  16
#&gt; 2 2025     4  17
</code></pre>
<pre><code class="language-r">fymd(2025, 4, 16) == res[1L]
</code></pre>
<pre><code>#&gt; [1] TRUE
</code></pre>
<p>Invalid dates will return <code>NA</code> and a warning:</p>
<pre><code class="language-r">fymd(2021, 02, 29) # not a leap year
</code></pre>
<pre><code class="language-plain warning">#&gt; NAs introduced due to invalid month and/or day combinations.
</code></pre>
<pre><code>#&gt; [1] NA
</code></pre>
<p>More interesting is the handling of output after a valid date. Consider the
following timestamp:</p>
<pre><code class="language-r">timelt &lt;- as.POSIXlt(Sys.time(), tz = &quot;UTC&quot;)
(timestamp &lt;- strftime(timelt, &quot;%Y-%m-%dT%H:%M:%S%z&quot;))
</code></pre>
<pre><code>#&gt; [1] &quot;2025-10-03T08:50:17+0000&quot;
</code></pre>
<p>By default the time element is ignored:</p>
<pre><code class="language-r">(res &lt;- fymd(timestamp))
</code></pre>
<pre><code>#&gt; [1] &quot;2025-10-03&quot;
</code></pre>
<pre><code class="language-r">res == as.Date(timestamp, tz = &quot;UTC&quot;)
</code></pre>
<pre><code>#&gt; [1] TRUE
</code></pre>
<p>This ignoring of the timestamp is both good and bad. For timestamps it makes
perfect sense, but perhaps you have simple dates and a concern that some are
corrupted. For these we can use the <code>strict</code> argument:</p>
<pre><code class="language-r">cdate &lt;- &quot;2025-04-16nonsense &quot;
fymd(cdate)
</code></pre>
<pre><code>#&gt; [1] &quot;2025-04-16&quot;
</code></pre>
<pre><code class="language-r">fymd(cdate, strict = TRUE)
</code></pre>
<pre><code class="language-plain warning">#&gt; NAs introduced due to invalid date strings.
</code></pre>
<pre><code>#&gt; [1] NA
</code></pre>
<h2 id="sec:benchmarks">Benchmarks</h2>
<div class="callout-important" data-legend="Comparison with fasttime::fastDate()">
<p>The character method  of <code>fymd()</code> parses input strings in a fixed, year, month
and day order. These values must be digits but can be separated by any non-digit
character. This is similar in spirit to the <code>fastDate()</code> function in Simon
Urbanek’s <a href="https://CRAN.R-project.org/package=fasttime">fasttime</a> package, using
pure text parsing and no system calls for maximum speed.</p>
<p>For extremely fast passing of POSIX style timestamps you will struggle to beat
the performance of <a href="https://CRAN.R-project.org/package=fasttime">fasttime</a>. This
works fantastically for timestamps that do not need validation and are within
the date range supported by the package (currently 1970-01-01 through to the
year 2199).</p>
<p><code>fymd()</code> fills the, admittedly small, niche where you want fast parsing of YMD
strings along with date validation and support for a wider range of dates from
the <a href="https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">Proleptic Gregorian calendar</a>
(currently we support years in the range <code>[-9999, 9999]</code>). This additional
capability does come with a small performance penalty but, hopefully, this has
been kept to a minimum and the implementation remains competitive.</p>
</div>
<pre><code class="language-r">library(microbenchmark)

# 1970-01-01 (UNIX epoch) to &quot;2199-01-01&quot;
dates &lt;- seq.Date(from = .Date(0), to = fymd(&quot;2199-01-01&quot;), by = &quot;day&quot;)

# comparison timings for fymd (character method)
cdates  &lt;- format(dates)
(res_c &lt;- microbenchmark(
    fasttime  = fasttime::fastDate(cdates),
    fastymd   = fymd(cdates),
    ymd       = ymd::ymd(cdates),
    lubridate = lubridate::ymd(cdates),
    check     = &quot;equal&quot;
))
</code></pre>
<pre><code>#&gt; Unit: microseconds
#&gt;       expr      min       lq      mean    median        uq      max neval
#&gt;   fasttime  533.670  538.575  577.8399  540.6035  544.7715 2105.967   100
#&gt;    fastymd  817.212  822.011  891.7562  824.8310  828.7085 5767.230   100
#&gt;        ymd 4236.551 4281.931 4395.9070 4313.1145 4336.5280 5953.068   100
#&gt;  lubridate 5486.083 5599.050 6219.0921 5668.7810 7022.4130 8608.015   100
</code></pre>
<pre><code class="language-r"># comparison timings for fymd (numeric method)
ymd  &lt;- get_ymd(dates)
(res_n &lt;- microbenchmark(
    fastymd   = fymd(ymd[[1]], ymd[[2]], ymd[[3]]),
    lubridate = lubridate::make_date(ymd[[1]], ymd[[2]], ymd[[3]]),
    check     = &quot;equal&quot;
))
</code></pre>
<pre><code>#&gt; Unit: microseconds
#&gt;       expr     min       lq     mean  median       uq      max neval
#&gt;    fastymd 325.480 326.7925 356.3634 328.165 332.5630 1956.998   100
#&gt;  lubridate 676.659 720.7870 839.9302 723.551 726.2465 2585.256   100
</code></pre>
<pre><code class="language-r"># comparison timings for year getter
(res_get_year &lt;- microbenchmark(
    fastymd   = get_year(dates),
    ymd       = ymd::year(dates),
    lubridate = lubridate::year(dates),
    check     = &quot;equal&quot;
))
</code></pre>
<pre><code>#&gt; Unit: microseconds
#&gt;       expr      min        lq      mean    median       uq       max neval
#&gt;    fastymd  358.942  359.8645  399.9320  360.9220  364.338  3179.119   100
#&gt;        ymd  381.245  394.3240  545.4191  403.5015  478.542  3748.817   100
#&gt;  lubridate 7564.449 7583.4395 8110.1502 7602.2950 8880.130 10426.904   100
</code></pre>
<pre><code class="language-r"># comparison timings for month getter
(res_get_month &lt;- microbenchmark(
    fastymd   = get_month(dates),
    ymd       = ymd::month(dates),
    lubridate = lubridate::month(dates),
    check     = &quot;equal&quot;
))
</code></pre>
<pre><code>#&gt; Unit: microseconds
#&gt;       expr      min        lq      mean    median        uq       max neval
#&gt;    fastymd  325.219  326.5470  328.9860  327.5240  330.8250   352.291   100
#&gt;        ymd  417.141  425.0265  436.5834  433.5175  442.9205   712.876   100
#&gt;  lubridate 8234.756 8273.7135 9062.5125 8289.4180 9659.8770 38708.926   100
</code></pre>
<pre><code class="language-r"># comparison timings for mday getter
(res_get_mday &lt;- microbenchmark(
    fastymd   = get_mday(dates),
    ymd       = ymd::mday(dates),
    lubridate = lubridate::day(dates),
    check     = &quot;equal&quot;
))
</code></pre>
<pre><code>#&gt; Unit: microseconds
#&gt;       expr      min        lq      mean    median        uq       max neval
#&gt;    fastymd  361.417  362.0785  378.6033  364.0725  366.4865  1695.318   100
#&gt;        ymd  421.540  426.5440  434.1789  429.9460  433.9390   790.311   100
#&gt;  lubridate 7541.686 7561.8090 7842.8506 7578.0845 7617.9145 10427.656   100
</code></pre>
</div>
</body>
</html>
